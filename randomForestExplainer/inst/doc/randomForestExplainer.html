<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Ola Paluszyńska" />


<title>Understanding random forests with randomForestExplainer</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Understanding random forests with randomForestExplainer</h1>
<h4 class="author"><em>Ola Paluszyńska</em></h4>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This is a preliminary draft of the vignette for <code>randomForestExplainer</code> package. I will provide examples of usage of new functions as I create them to track package development.</p>
<p>I will use the following packages:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(data.table)
<span class="kw">library</span>(dplyr)
<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(randomForest)</code></pre></div>
</div>
<div id="data" class="section level1">
<h1>Data</h1>
<p>I will use the data on Glioblastoma that contain only 125 observations but 16119 variables. The goal of my random forest will be to predict whether the patient died or not within a year from diagnosis (variable <code>death1y</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">load</span>(<span class="st">&quot;GlioblastomaWide.rda&quot;</span>)</code></pre></div>
<p>First I need to change our dependent variable into a factor and remove variables for which there are NAs (otherewise we would have to remove corresponding observations to build a random forest and our sample is very small anyway). Additionally, I remove the variable <code>sampleID</code> which is just the ID of the patient.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">GlioblastomaWide$death1y &lt;-<span class="st"> </span><span class="kw">as.factor</span>(GlioblastomaWide$death1y)
remove &lt;-<span class="st"> </span><span class="kw">is.na</span>(GlioblastomaWide) %&gt;%<span class="st"> </span><span class="kw">colSums</span>()
GlioblastomaWide &lt;-<span class="st"> </span>GlioblastomaWide[, remove ==<span class="st"> </span><span class="dv">0</span>]
<span class="kw">rm</span>(remove)
GlioblastomaWide &lt;-<span class="st"> </span>GlioblastomaWide[, -<span class="dv">1</span>]</code></pre></div>
<p>Now, I use the <code>randomForest</code> package to build a random forest for the data. I need the forest to have as many trees as possible, as with thousands of variables the probablility of each being considered for a split of a node is low and for analyzing the structure of the random forest I need a reasonable number of such instances for each variable, as I cannot say anything about the importance of a variable that was not even considered for a split.</p>
<p>As building of the below forest takes a long time I load it from the memory.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># forest &lt;- randomForest(death1y ~ ., data = GlioblastomaWide, ntree = 10000)</span>
<span class="co"># save(forest, file = &quot;GlioblastomaWide_forest.rda&quot;)</span>
<span class="kw">load</span>(<span class="st">&quot;GlioblastomaWide_forest.rda&quot;</span>)</code></pre></div>
<p>[here we will check if the random forest is a reasonable predictor]</p>
</div>
<div id="minimal-depth" class="section level1">
<h1>Minimal depth</h1>
<div id="distribution-of-minimal-depth" class="section level2">
<h2>Distribution of minimal depth</h2>
<p>At this point I will demonstrate new ways in which a random forest can be interpreted using the distribution of minimal depth across its trees. Below, I show how to use the four functions provided in the file min_depth_distribution.R to explore my random forest.</p>
<p>The most fundamental building block here is the function <code>calculate_tree_depth</code> that calculates the depth of each node for a single tree. As an argument, it takes the data frame produced by the <code>randomForest::getTree</code> function. I consider the first tree from our forest:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">frame &lt;-<span class="st"> </span><span class="kw">getTree</span>(forest, <span class="dt">k =</span> <span class="dv">1</span>, <span class="dt">labelVar =</span> <span class="ot">TRUE</span>) <span class="co"># the argument labelVar has to be set to TRUE!</span>
<span class="kw">head</span>(frame) <span class="co"># this is how such frame looks like</span></code></pre></div>
<pre><code>##   left daughter right daughter split var split point status prediction
## 1             2              3    B3GNT8     -2.8125      1       &lt;NA&gt;
## 2             4              5    CHRNB2      5.9725      1       &lt;NA&gt;
## 3             6              7    TNNI3K      1.9100      1       &lt;NA&gt;
## 4             8              9      OAS2     -2.8285      1       &lt;NA&gt;
## 5             0              0      &lt;NA&gt;      0.0000     -1       dead
## 6            10             11     NCOA1      0.6485      1       &lt;NA&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">calculate_tree_depth</span>(frame)) <span class="co"># this is what our function produces</span></code></pre></div>
<pre><code>##   left daughter right daughter split var split point status prediction
## 1             2              3    B3GNT8     -2.8125      1       &lt;NA&gt;
## 2             4              5    CHRNB2      5.9725      1       &lt;NA&gt;
## 3             6              7    TNNI3K      1.9100      1       &lt;NA&gt;
## 4             8              9      OAS2     -2.8285      1       &lt;NA&gt;
## 5             0              0      &lt;NA&gt;      0.0000     -1       dead
## 6            10             11     NCOA1      0.6485      1       &lt;NA&gt;
##   depth
## 1     0
## 2     1
## 3     1
## 4     2
## 5     2
## 6     2</code></pre>
<p>The function <code>min_depth_distribution</code> builds upon the above result – it creates one data frame for the whole forest and then for each tree calculates the minimal depth of all variables that were used for splitting within it. It takes the forest as its argument and returns a data frame with the distribution of minimal depth across trees.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">min_depth_frame &lt;-<span class="st"> </span><span class="kw">min_depth_distribution</span>(forest)
<span class="kw">head</span>(min_depth_frame, <span class="dt">n =</span> <span class="dv">10</span>) <span class="co"># this is how the output looks like</span></code></pre></div>
<pre><code>##    tree variable minimal_depth
## 1     1   ANP32B             4
## 2     1   B3GNT8             0
## 3     1     CBLB             4
## 4     1   CHRNB2             1
## 5     1    CLDN7             2
## 6     1  COL16A1             5
## 7     1     EHD4             4
## 8     1    NCOA1             2
## 9     1     OAS2             2
## 10    1    PCGF3             3</code></pre>
<p>It is worth noting, that using this function we only get data concerning the minimal depth for each variable that was used for splitting in a given tree. We do not fill the frame with NAs whenever a variable does not have a minimal depth in a tree (because it was not used for splitting in it) as when there are many variables (as is the case in our example) the resulting data frame would be enormous and one could easily run out of memory and get an error. In other cases it is simple to do with the following code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># library(tidyr)</span>
<span class="co"># min_depth_frame &lt;- tidyr::complete(min_depth_frame, tree = 1:forest$ntree, variable = labels(forest$terms))</span></code></pre></div>
<p>The function <code>min_depth_count</code> counts how many times each variable had each minimal depth in a tree. It also takes into account the instances when a variable did not appear as split variable in a tree (then <code>minimal_depth = NA</code>). It takes the result of <code>min_depth_distribution</code> as an argument and returns a list of two data frames presented below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">min_depth_count_list &lt;-<span class="st"> </span><span class="kw">min_depth_count</span>(min_depth_frame)
<span class="kw">head</span>(min_depth_count_list[[<span class="dv">1</span>]], <span class="dt">n =</span> <span class="dv">10</span>)</code></pre></div>
<pre><code>##    variable minimal_depth count
## 1    ANP32B             2     2
## 2    ANP32B             3     2
## 3    ANP32B             4     4
## 4    ANP32B             5     2
## 5    ANP32B            NA  9990
## 6    B3GNT8             0     2
## 7    B3GNT8             1     2
## 8    B3GNT8             2     5
## 9    B3GNT8             3     4
## 10   B3GNT8             4     2</code></pre>
<p>The first data frame from the list (above) contains the count of occurances of each variable and minimal_depth combination.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(min_depth_count_list[[<span class="dv">2</span>]], <span class="dt">n =</span> <span class="dv">10</span>)</code></pre></div>
<pre><code>##    variable no_of_occurances
## 1    ANP32B               10
## 2    B3GNT8               15
## 3      CBLB               15
## 4    CHRNB2               14
## 5     CLDN7               18
## 6   COL16A1               24
## 7      EHD4                6
## 8     NCOA1               12
## 9      OAS2               11
## 10    PCGF3                8</code></pre>
<p>The second data frame from the list (above) contains the number of trees in which each variable appeared as a splitting variable.</p>
<p>Finally, the function <code>plot_min_depth_distribution</code> plots the minimal depth distribution for a maximum of <code>k</code> variables with highest mean minimal depth (default is 10). For this, only variables that were used for splitting in at least <code>min_no_of_trees</code> number of trees are used – this argument is of particular interest in cases with many variables like in our example, as some variables may have a low mean minimal depth only due to chance (e.g., they were present only in one out of 10000 trees and there happend to be used to splitting close to the root). The default value for this parameter is half of the maximal number of trees in which any variable was used for splitting (in our case this is half of 94).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot_min_depth_distribution</span>(min_depth_frame)</code></pre></div>
<p><img src="data:image/png;base64,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" alt /><!-- --></p>
<p>The vertical bar indicates the mean minimal depth rescaled such that the maximal possible value is the maximal number of trees in which any variable was used for splitting (this is 94 in our case – for variable SH3BP2). Note, that the number of NA’s plotted is the number of NA’s that a variable has on top of the minimal number of NA’s.</p>
<p>Below, we use the function again with different options:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot_min_depth_distribution</span>(min_depth_frame, <span class="dt">k =</span> <span class="dv">15</span>, <span class="dt">min_no_of_trees =</span> <span class="dv">50</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" alt /><!-- --></p>
<p>Of course, the result is very sensitive to changes in parameters <code>k</code> and <code>min_no_of_trees</code>. This is because we have so many variables and their occurance as split variables is generally rare (less than 0.1%). That is just another argument for looking at the whole distribution of minimal depth instead of mean minimal depth, especially for such datasets as this one.</p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
